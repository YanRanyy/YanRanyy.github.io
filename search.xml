<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git使用</title>
      <link href="/2024/11/26/Git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/11/26/Git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="Git的使用"><a href="#Git的使用" class="headerlink" title="Git的使用"></a>Git的使用</h3><p><img src="C:\Users\云雨\Pictures\markdown引用\git指令速查表.jpg"></p><p>1、每次在项目目录使用都要初始化，输入指令git init</p><p>2、把当前项目下所有文件添加到临时存储仓库:git add .</p><p>如果只添加某个文件，就输入git add 具体路径</p><p>3、把临时存储仓库转为正式储存:git commit -m “注释”</p><p>查看提交记录:git log</p><p>按照版本号回退代码:git reset –hard 版本号</p><p>4、将本地仓库和远程仓库关联。</p><p>git remote add origin 远程仓库链接地址<br>注：远程仓库链接地址在github上找。 </p><p>5、本地编辑代码后提交至远程分支。</p><p>git push -u origin master<br> 重要：第一次使用加上了 -u 参数，是推送内容并关联分支，之后推送直接使用git push即可，因为第一次已经将当前本地master分支和远程origin的master分支关联了。</p><p>xxxxxxxxxx #include<iostream>​using namespace std;​const int N &#x3D; 100010;​int n, m;int a[N], s[N];​int main(){    scanf(“%d%d”, &amp;n, &amp;m);​    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) scanf(“%d”, &amp;a[i]);       for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) s[i] &#x3D; s[i - 1] + a[i];​    while(m –)    {        int l, r;        scanf(“%d%d”, &amp;l, &amp;r);        printf(“%d\n”, s[r] - s[l - 1]);    }​    return 0;}​c++</p><p>6、检查远程仓库是否有新提交的内容。</p><p><img src="C:\Users\云雨\Pictures\markdown引用\a335bfdd5be24f85a18e6c81af0b38fa.png"></p><p>二、拉取远程分支到本地（已有远程仓库）<br>1、在github找仓库地址。</p><p><img src="C:\Users\云雨\Pictures\markdown引用\a61945cb626e46c1a8cb930bfbe5ccb6.png"></p><p>2、在本地下载远程仓库代码。</p><p>git clone 远程仓库地址</p><p>3、将远程分支拉到本地。</p><p><img src="C:\Users\云雨\Pictures\markdown引用\f9aae077659e439ebdbf30d1fe8e4114.png"></p><p>git fetch origin 远程分支名<br> 4、本地关联远程分支，本地分支名可随意写。</p><p>git checkout -b 本地分支名称 origin&#x2F;远程分支名称<br> 5、拉取远程分支代码。</p><p>git pull origin</p><p><img src="C:\Users\云雨\Pictures\markdown引用\6559f26419734ee2ba49a521a372b202.png"></p><p>————————————————<br>原文链接：<a href="https://blog.csdn.net/qq_27688393/article/details/126669161">https://blog.csdn.net/qq_27688393/article/details/126669161</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用镜像源</title>
      <link href="/2024/11/26/%E5%B8%B8%E7%94%A8%E9%95%9C%E5%83%8F%E6%BA%90/"/>
      <url>/2024/11/26/%E5%B8%B8%E7%94%A8%E9%95%9C%E5%83%8F%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h3 id="一、国内常用镜像源"><a href="#一、国内常用镜像源" class="headerlink" title="一、国内常用镜像源"></a>一、国内常用镜像源</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">清华大学 ：https://pypi.tuna.tsinghua.edu.cn/simple/</span><br></pre></td></tr></table></figure><p>阿里云：<a href="https://so.csdn.net/so/search?q=http&spm=1001.2101.3001.7020">http</a>:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;<a href="https://so.csdn.net/so/search?q=pypi&spm=1001.2101.3001.7020">pypi</a>&#x2F;simple&#x2F;</p><p>中国科学技术大学 ：<a href="http://pypi.mirrors.ustc.edu.cn/simple/">http://pypi.mirrors.ustc.edu.cn/simple/</a></p><p>华中科技大学：<a href="http://pypi.hustunique.com/">http://pypi.hustunique.com/</a></p><p><a href="https://so.csdn.net/so/search?q=%E8%B1%86%E7%93%A3%E6%BA%90&spm=1001.2101.3001.7020">豆瓣源</a>：<a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></p><p>腾讯源：<a href="http://mirrors.cloud.tencent.com/pypi/simple">http://mirrors.cloud.tencent.com/pypi/simple</a></p><p>华为镜像源：<a href="https://repo.huaweicloud.com/repository/pypi/simple/">https://repo.huaweicloud.com/repository/pypi/simple/</a></p><p>查看当前<a href="https://so.csdn.net/so/search?q=pip%E6%BA%90&spm=1001.2101.3001.7020">pip源</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip config <span class="built_in">list</span></span><br></pre></td></tr></table></figure><h3 id="二、临时使用"><a href="#二、临时使用" class="headerlink" title="二、临时使用"></a>二、临时使用</h3><p>格式：<br>pip install [包名] -i [pip源URL]</p><p>#示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pymysql</span><br></pre></td></tr></table></figure><h3 id="三、设置代理"><a href="#三、设置代理" class="headerlink" title="三、设置代理"></a>三、设置代理</h3><p>设置代理(cmd, bash, powershell)</p><p>默认模式：http代理(一般为socks+1)<br>set http_proxy&#x3D;<a href="http://127.0.0.1:本地端口">http://127.0.0.1:本地端口</a><br>set https_proxy&#x3D;<a href="http://127.0.0.1:本地端口">http://127.0.0.1:本地端口</a></p><p>bash模式：sock5代理<br>export https_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:本地端口<br>export http_proxy&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:本地端口</p><p>PowerShell ：http代理<br>$env:http_proxy&#x3D;<a href="http://127.0.0.1:本地端口">http://127.0.0.1:本地端口</a><br>$env:https_proxy&#x3D;<a href="http://127.0.0.1:本地端口">http://127.0.0.1:本地端口</a></p><h3 id="临时使用proxy"><a href="#临时使用proxy" class="headerlink" title="临时使用proxy"></a>临时使用proxy</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 直接在后面加上</span><br><span class="line">--proxy http://127.0.0.1:本地端口</span><br><span class="line">示例:pip install [包名] --proxy http://127.0.0.1:本地端口</span><br><span class="line">如果超时可以改成:</span><br><span class="line">pip --default-timeout=100 install [包名] --proxy http://127.0.0.1:本地端口</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 镜像源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YOLOv5使用</title>
      <link href="/2024/11/26/YOLOv5%E6%A8%A1%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2024/11/26/YOLOv5%E6%A8%A1%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="YOLOv5模型使用教程-待更"><a href="#YOLOv5模型使用教程-待更" class="headerlink" title="YOLOv5模型使用教程(待更)"></a>YOLOv5模型使用教程(待更)</h1><h2 id="安装与改各种东西"><a href="#安装与改各种东西" class="headerlink" title="安装与改各种东西"></a>安装与改各种东西</h2><p>1:前往Anaconda.rog安装Anaconda,这是一个python环境隔离工具</p><p>2:在github下载YOLOv5源码，这里推荐6.0版本</p><p>3:在安装Anaconda的时候，有4个小方框的地方要勾选1 2 4选项，这是安装环境配置，如果不勾选，后续自己添加非常非常非常非常非常麻烦</p><p>4:解压YOLOv5，然后打开requirements.txt,把依赖的库版本&gt;&#x3D;全改成&#x3D;&#x3D;</p><p>如图:<img src="C:\Users\云雨\Pictures\QQ20241016-183702.png" alt="QQ20241016-183702"></p><p>5:打开cmd控制台，输入conda env list   如果没创建过项目，那只会出现base</p><p>接下来再输入conda create -n yolo_v5 python&#x3D;3.8   (python的3.8最稳定)</p><p>然后在安装过程中要求选择Proceed([y]&#x2F;n)?  全选择y就行</p><p>然后输入conda activate yolo_v5</p><p>然后用cd指令转去你解压的YOLOv5-6.0的文件夹地址，如果提示文件名、目录名或卷标语法不正确，那就改成cd&#x2F;d 地址</p><p>6:先别关控制台，然后我们先去下载一个pyTorch插件(地址:pytorch.org)</p><p>然后注意到，我们的requirements里面有提到，要使用torch&#x3D;&#x3D;1.7.0的版本，如果直接使用pyTorch的最新2.0版本肯定是会报错的，所以我们要去翻历史版本</p><h3 id="这里不得不提到说是1-7-0，但还是得用1-8-1"><a href="#这里不得不提到说是1-7-0，但还是得用1-8-1" class="headerlink" title="这里不得不提到说是1.7.0，但还是得用1.8.1"></a>这里不得不提到说是1.7.0，但还是得用1.8.1</h3><p>然后我们翻到历史版本的</p><p><img src="C:\Users\云雨\Pictures\QQ_1729075622947.png" alt="QQ_1729075622947"></p><p>如果你是30系及以上的显卡，那就按11.1，如果配置比较低，那就试试后面这几个</p><p>直接复制这个:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torch==1.8.1+cu111 torchvision==0.9.1+cu111 torchaudio==0.8.1 -f https://download.pytorch.org/whl/torch_stable.html</span><br></pre></td></tr></table></figure><p>到之前的cmd控制台，一定要在(yolov5)环境里面安装，才能够成功<img src="C:\Users\云雨\Pictures\QQ20241016-185058.png" alt="QQ20241016-185058"></p><p>如果成功了，那就会出现这个界面，要下蛮久的，如果之前有安装过，那会直接检测到就拿过来用了，如果中途中断了的话，就要重新开始下</p><p>如果无论怎么换源你的网速都很慢，那就挂个梯子然后在pip指令后面加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--proxy http://127.0.0.1:本地端口</span><br></pre></td></tr></table></figure><p>如果下载途中经常下一半就报错一大片红色代码，就试试把</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip --default-timeout=100 install</span><br></pre></td></tr></table></figure><p>下载完成后会提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Installing collected packages: typing-extensions, pillow, numpy, torch, torchvision, torchaudio</span><br><span class="line">Successfully installed numpy-1.24.4 pillow-10.4.0 torch-1.8.1+cu111 torchaudio-0.8.1 torchvision-0.9.1+cu111 typing-extensions-4.12.2</span><br></pre></td></tr></table></figure><p>然后我们输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python</span><br></pre></td></tr></table></figure><p>进入交互环境，然后输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br></pre></td></tr></table></figure><p>如果没报错，那就是成功了，然后输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit()</span><br></pre></td></tr></table></figure><p>退出</p><p>回到requirements.txt文档</p><p>把torch和torchvision这两个东西注释掉，因为我们已经手动安装了</p><h3 id="这里提一嘴为什么要手动安装，因为它给的pip下载是下载用cpu训练的，我们用gpu训练得手动去下"><a href="#这里提一嘴为什么要手动安装，因为它给的pip下载是下载用cpu训练的，我们用gpu训练得手动去下" class="headerlink" title="这里提一嘴为什么要手动安装，因为它给的pip下载是下载用cpu训练的，我们用gpu训练得手动去下"></a>这里提一嘴为什么要手动安装，因为它给的pip下载是下载用cpu训练的，我们用gpu训练得手动去下</h3><p>改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># torch==1.7.0</span><br><span class="line"># torchvision==0.8.1</span><br></pre></td></tr></table></figure><p>然后再把opencv改一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opencv-python==4.1.2.30 #(如果没有4.1.2.30就改成尽可能低的版本)</span><br></pre></td></tr></table></figure><p>然后去运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>没有报错安装好依赖就可以下一步了</p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>经历了繁琐的安装配置后，终于可以开始训练了QAQ</p><p>我们去vscode(或者你用别的编译器,如果是vscode记得要下载python的拓展)打开刚才解压的YOLOv5文件夹，就可以浏览里边的代码了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">train.py(训练)</span><br><span class="line">val.py(验证)</span><br><span class="line">detect.py(检测)</span><br></pre></td></tr></table></figure><p>在vscode里按住Ctrl+Shift+P，然后输入选择解释器，选择python3.8</p><h3 id="数据集获取"><a href="#数据集获取" class="headerlink" title="数据集获取"></a>数据集获取</h3><p>可以登录<a href="https://huggingface.co/%E7%BD%91%E7%AB%99%E8%8E%B7%E5%8F%96%EF%BC%8C%E6%90%9C%E7%B4%A2object">https://huggingface.co/网站获取，搜索object</a> detect就可以了</p><p>把我们的数据集放在yolo文件夹里的data文件夹里</p><p>注意tarin和val文件夹是必须要有的，里面必须严格按照images和lables来命名文件夹存放图片和标签，images里面放你需要用于训练的图片，lables是训练图片的标签(直接把训练图片的后缀jpg改成txt，名称完全一致就好了)</p><p>处理好数据集后，在YOLOv5文件根目录创建一个py项目，测试能否读取到图片和边框是否正确，我把代码贴在下面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># 指定图片路径</span></span><br><span class="line">image_path = <span class="string">&#x27;./data/data_org/train/images/2_py.jpg&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图片</span></span><br><span class="line">image = cv.imread(image_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查图片是否读取成功</span></span><br><span class="line"><span class="keyword">if</span> image <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;图片未能读取，请检查路径。&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 在图像上绘制矩形</span></span><br><span class="line">    image = cv.rectangle(image, (<span class="number">78</span>, <span class="number">15</span>), (<span class="number">559</span> + <span class="number">78</span>, <span class="number">622</span> + <span class="number">15</span>), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 显示图像</span></span><br><span class="line">    cv.imshow(<span class="string">&quot;img&quot;</span>, image)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">0</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">         cv.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>正常来讲，会出现这种窗口</p><p>–&gt;<img src="C:\Users\云雨\AppData\Local\Temp\QQ_1730725122602.png" alt="img"></p><h3 id="数据集处理思路"><a href="#数据集处理思路" class="headerlink" title="数据集处理思路"></a>数据集处理思路</h3><p>由于我们放入的数据集肯定是一大坨东西，然后只输出一小坨东西</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YOLO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和算法</title>
      <link href="/2024/11/26/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>/2024/11/26/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="一维数组前缀和"><a href="#一维数组前缀和" class="headerlink" title="一维数组前缀和"></a>一维数组前缀和</h2><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>给定一个 a <a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">数组</a>，请求出它的前缀和数组 s ：</p><p><img src="https://img-blog.csdnimg.cn/af14c3252bdb4d7b9725b75ecbb2b6fd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6L6j6L6j5rqc5rqc5qKF,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>那么 a 数组的前缀和数组为：</p><p><img src="https://img-blog.csdnimg.cn/cdd7dbadd1b14860babc4e3fd76da98d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6L6j6L6j5rqc5rqc5qKF,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>a 数组与 s 数组之间满足：s[ i ] &#x3D; a[ 0 ] + a[ 1 ] + a[ 2 ] + … + a[ i ]<br>但是，由于我们在计算前缀和时，为了更加方便，我们会将数组下标从 1 开始存入和读取。<br>所以，我们的 s 前缀和数组为： s[ i ] &#x3D; a[ 1 ] + a[ 2 ] + … + a[ i ]</p><p>应用<br>若是要求某个区间的和该怎么办？<br>用以上的例子，我们想求 a 数组中下标从 3 到 6 的数值的和。如下图：</p><p><img src="https://img-blog.csdnimg.cn/2a88e6dd7df545869bc4426ce1ae8261.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6L6j6L6j5rqc5rqc5qKF,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>用<strong>前缀和原理</strong>分析可知：a[ 3 ] + a[ 4 ] + a[ 5 ] + a[ 6 ] &#x3D; s[ 6 ] - s[ 2 ]<br>根据以上原理，很容易实现代码。</p><h3 id="示例题目"><a href="#示例题目" class="headerlink" title="示例题目"></a>示例题目</h3><p>题目：前缀和<br>输入一个长度为 n 的整数序列。<br>接下来再输入 m 个询问，每个询问输入一对 l,r。<br>对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。<br>输入格式<br>第一行包含两个整数 n 和 m。<br>第二行包含 n 个整数，表示整数数列。<br>接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。<br>输出格式<br>共 m 行，每行输出一个询问的结果。<br>数据范围<br>1≤l≤r≤n ,<br>1≤n,m≤100000,<br>−1000≤数列中元素的值≤1000<br>输入样例：<br>5 3<br>2 1 3 6 4<br>1 2<br>1 3<br>2 4<br>输出样例：<br>3<br>6<br>10<br>————————————————</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KNN算法</title>
      <link href="/2024/11/26/KNN%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/26/KNN%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="KNN算法"><a href="#KNN算法" class="headerlink" title="KNN算法"></a>KNN算法</h1><h2 id="KNN概念"><a href="#KNN概念" class="headerlink" title="KNN概念"></a>KNN概念</h2><p>1.K近邻算法，即是给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的K个实例，这K个实例的多数属于某个类，就把该输入实例分类到这个类中。</p><p>例如下图展现了两类样本数据，分别由正方形和三角形表示，待分类数据由圆形表示，算法的目的是依据已知的样本数据判断待分类数据的类别，即对圆形数据分类。</p><p><img src="https://img-blog.csdnimg.cn/direct/6bd12a93f2844a90ae3534f96b70a62d.png" alt="img"></p><h2 id="距离度量的选择"><a href="#距离度量的选择" class="headerlink" title="距离度量的选择"></a>距离度量的选择</h2><p>k近邻算法中需要按照距离递增次序排序，通常选取以下类型的距离：</p><p><img src="https://latex.csdn.net/eq?x_%7Bi%7D=%5Cleft(x_%7Bi%7D%5E%7B(1)%7D,x_%7Bi%7D%5E%7B(2)%7D,%5Ccdots,x_%7Bi%7D%5E%7B(n)%7D%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D" alt="x_{i}=\left(x_{i}^{(1)},x_{i}^{(2)},\cdots,x_{i}^{(n)}\right)^{\mathrm{T}}"></p><ul><li>欧式距离：<img src="https://latex.csdn.net/eq?L_%7B2%7D(x_%7Bi%7D,x_%7Bj%7D)=%5Cleft(%5Csum_%7Bl=1%7D%5E%7Bn%7D%7Cx_%7Bi%7D%5E%7B(l)%7D-x_%7Bj%7D%5E%7B(l)%7D%7C%5E%7B2%7D%5Cright)%5E%7B%5Cfrac%7B1%7D%7B2%7D%7D" alt="L_{2}(x_{i},x_{j})=\left(\sum_{l=1}^{n}|x_{i}^{(l)}-x_{j}^{(l)}|^{2}\right)^{\frac{1}{2}}"></li><li>Lp距离：<img src="https://latex.csdn.net/eq?L_%7Bp%7D(x_%7Bi%7D,x_%7Bj%7D)=%5Cleft(%5Csum_%7Bl=1%7D%5E%7Bn%7D%5Cmid%20x_%7Bi%7D%5E%7B(l)%7D-x_%7Bj%7D%5E%7B(l)%7D%5Cmid%5E%7Bp%7D%5Cright)%5E%7B%5Cfrac%7B1%7D%7Bp%7D%7D" alt="L_{p}(x_{i},x_{j})=\left(\sum_{l=1}^{n}\mid x_{i}^{(l)}-x_{j}^{(l)}\mid^{p}\right)^{\frac{1}{p}}"></li><li>曼哈顿距离：<img src="https://latex.csdn.net/eq?L_%7B1%7D(x_%7Bi%7D,x_%7Bj%7D)=%5Csum_%7Bl=1%7D%5E%7Bn%7D%7Cx_%7Bi%7D%5E%7B(l)%7D-x_%7Bj%7D%5E%7B(l)%7D%7C" alt="L_{1}(x_{i},x_{j})=\sum_{l=1}^{n}|x_{i}^{(l)}-x_{j}^{(l)}|"></li><li>L<img src="https://latex.csdn.net/eq?%5Cinfty" alt="\infty">距离：<img src="https://latex.csdn.net/eq?L_%7B%5Cinfty%7D(x_%7Bi%7D,x_%7Bj%7D)=%5Cmax_%7Bl%7D%5Cmid%20x_%7Bi%7D%5E%7B(l)%7D-x_%7Bj%7D%5E%7B(l)%7D%5Cmid" alt="L_{\infty}(x_{i},x_{j})=\max_{l}\mid x_{i}^{(l)}-x_{j}^{(l)}\mid"></li></ul><p>计算距离一般使用欧氏距离公式，<img src="C:\Users\云雨\Pictures\欧几里得公式.png" alt="欧几里得公式"></p><p>K值少数服从多数，由最近的k个邻居决定判别点的归属</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>1.计算已知数据集的多个点和当前点的距离</p><p>2.按照距离递增排序</p><p>3.选取当前点距离最近的k个点</p><p>4.确定这k个点的类别所出现频率</p><p>5.返回k个点出现频率最高的类别作为预测类别</p><h2 id="数据集选择"><a href="#数据集选择" class="headerlink" title="数据集选择"></a>数据集选择</h2><p>用黑白手写数字识别举例，KNN算法不需要太多数据集，如只需要黑白，可以用ps手写,规定好数据集的范围，如都是28x28,32x32</p><h2 id="k值的选择"><a href="#k值的选择" class="headerlink" title="k值的选择"></a>k值的选择</h2><p>选择较小的k值<br>噪声敏感<br>K值的减小意味着着整体模型会变得复杂，容易发生过拟合情况<br>学习的近似误差(approximation error)会减小，但学习的估计误差(estimation error)会增大</p><p>过拟合：在训练集上准确率非常高，而在测试集上准确率低</p><p>选择较大的k值<br>K值的增大意味着整体的模型会变得简单<br>学习的估计误差(estimation error)会减小，但学习的近似误差(approximation error)会增大<br>合理的选择方式：一般先选取一个较小的k值，然后采取交叉验证法来选取最优的k值，即实验调参，类似于神经网络通过调整超参数来得到一个较好的层数。</p><h2 id="KNN算法优缺点"><a href="#KNN算法优缺点" class="headerlink" title="KNN算法优缺点"></a>KNN算法优缺点</h2><p>优点:</p><p>1.精度高</p><p>2.对异常值不敏感</p><p>3.无数据输入假定</p><p>缺点:</p><p>1.计算复杂度高</p><p>2.空间复杂度高</p><h3 id="java方式将图片二值化"><a href="#java方式将图片二值化" class="headerlink" title="java方式将图片二值化"></a>java方式将图片二值化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将图片二值化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] imageTrainBit(File file) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">BufferedImage</span> <span class="variable">read</span> <span class="operator">=</span> ImageIO.read(file);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> read.getWidth();</span><br><span class="line">            <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> read.getHeight();</span><br><span class="line">            <span class="type">BufferedImage</span> <span class="variable">bufferedImage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedImage</span>(width, height, BufferedImage.TYPE_BYTE_GRAY);</span><br><span class="line">            <span class="type">Graphics2D</span> <span class="variable">graphics</span> <span class="operator">=</span> bufferedImage.createGraphics();</span><br><span class="line">            graphics.drawImage(read, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">            graphics.dispose();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">            <span class="comment">//用于存储图片的二值化数组</span></span><br><span class="line">            <span class="type">int</span> data[][] = <span class="keyword">new</span> <span class="title class_">int</span>[height][width];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; height; ++y) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; width; ++x) &#123;</span><br><span class="line">                    <span class="comment">//获取图片指定点的rgb色彩</span></span><br><span class="line">                    <span class="comment">//int rgb = read.getRGB(x,y);</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">gray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Color</span>(bufferedImage.getRGB(x, y)).getRed();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">binaryPixel</span> <span class="operator">=</span> gray &lt; threshold ? Color.BLACK.getRGB() : Color.WHITE.getRGB();</span><br><span class="line">                    <span class="comment">//binaryImage.setRGB(x,y,binaryPixel)</span></span><br><span class="line">                    data[y][x] = gray != <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="将二值化的图片转换为一维特征向量值"><a href="#将二值化的图片转换为一维特征向量值" class="headerlink" title="将二值化的图片转换为一维特征向量值"></a>将二值化的图片转换为一维特征向量值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将二值化的图片转换为一维特征向量值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] bitImageTrainVector(<span class="type">int</span> imageBit[][]) &#123;</span><br><span class="line">        <span class="type">int</span> data[] = <span class="keyword">new</span> <span class="title class_">int</span>[imageBit.length * imageBit[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>; y &lt; imageBit.length; ++y) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; imageBit[y].length; ++x) &#123;</span><br><span class="line">                data[imageBit[y].length * y + x] = imageBit[y][x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="特征数量"><a href="#特征数量" class="headerlink" title="特征数量"></a>特征数量</h3><p><strong>特征数量</strong> 是指在模型中每个样本所包含的独立变量或属性的数量。在图像识别中，每个图像可以被视为一个特征矩阵。具体来说：</p><ol><li><strong>每个像素作为特征</strong>：在处理图像时，图像的每个像素值都可以被视为一个特征。当图像被展平成一维数组时，数组的长度即为特征数量。例如，一个28x28的灰度图像有784个像素，因此它的特征数量为784。</li><li><strong>其他特征</strong>：除了直接使用像素值外，有时候会提取其他特征，如边缘、角点、纹理等，这些都是定义图像特征的方式。总特征数量可能包括所有这些特征。</li></ol><h3 id="为什么要转换成0-1矩阵"><a href="#为什么要转换成0-1矩阵" class="headerlink" title="为什么要转换成0-1矩阵"></a>为什么要转换成0-1矩阵</h3><p>将图像转换为0-1矩阵：</p><ol><li><strong>数据范围一致性</strong>：<ul><li>图像的原始像素值通常在0到255之间（对于8位灰度图像）。如果将其直接输入到KNN模型等算法中，各种特征由于数值上存在差异，可能导致模型无法有效地比较不同特征之间的距离。</li><li>将像素值转换为0-1范围内的浮点数可以保证特征值在同一尺度上，从而使得距离计算更加合理和准确。</li></ul></li><li><strong>提高收敛速度</strong>：<ul><li>在某些机器学习算法中，特征的尺度会影响模型的训练效率。通过统一特征的尺度，可以加速收敛过程，减少训练时间。</li></ul></li><li><strong>降低计算复杂度</strong>：<ul><li>在一些算法中，尤其是在计算距离的方法中（如欧几里得距离），特征值的大小差异会影响最终结果。统一特征值的范围可以降低计算复杂度，提高模型性能。</li></ul></li><li><strong>避免数值不稳定性</strong>：<ul><li>较大的数字可能导致浮点运算中的数值不稳定性，将特征缩放到0-1区间可以减少这种风险。</li></ul></li></ol><h2 id="基于C-的Opencv实现KNN算法识别手写黑白数字"><a href="#基于C-的Opencv实现KNN算法识别手写黑白数字" class="headerlink" title="基于C++的Opencv实现KNN算法识别手写黑白数字"></a>基于C++的Opencv实现KNN算法识别手写黑白数字</h2><h3 id="流程-假设你已经安装好了Opencv"><a href="#流程-假设你已经安装好了Opencv" class="headerlink" title="流程(假设你已经安装好了Opencv)"></a>流程(假设你已经安装好了Opencv)</h3><ol><li>引入库和定义数据结构。</li><li>检查文件的存在性。</li><li>加载训练图像并提取特征和标签。</li><li>训练 KNN 模型。</li><li>加载测试图像，转换为特征向量。</li><li>进行数字识别，返回预测结果。</li><li>输出识别结果。</li></ol><h3 id="需要引用的头文件"><a href="#需要引用的头文件" class="headerlink" title="需要引用的头文件"></a>需要引用的头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui_c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/ml.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv::ml;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br></pre></td></tr></table></figure><p><strong>结构体定义</strong>：定义一个名为 <code>xlsj</code> 的结构体，用于存储训练数据每个样本的特征和对应标签</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 训练数据结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">xlsj</span> &#123;</span><br><span class="line">    Mat features;  <span class="comment">// 特征向量</span></span><br><span class="line">    <span class="type">int</span> label;     <span class="comment">// 标签</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义一个名为 <code>KNNModel</code> 的结构体，用于存储 KNN 模型及其特征数量,使用智能指针Ptr管理KNN对象的内存，”numFeatures”存储特征矩阵列数方便后面的识别预测</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">KNNModel</span> &#123;</span><br><span class="line">    Ptr&lt;KNearest&gt; knn;</span><br><span class="line">    <span class="type">int</span> numFeatures;  <span class="comment">// 特征矩阵的列数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="文件存在性检查"><a href="#文件存在性检查" class="headerlink" title="文件存在性检查"></a>文件存在性检查</h3><p>检查指定路径的文件是否存在</p><p>使用 <code>ifstream</code> 尝试打开文件，如果成功则返回 <code>true</code>，否则返回 <code>false</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 检查文件是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fileExists</span><span class="params">(<span class="type">const</span> string&amp; filePath)</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(filePath)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> file.<span class="built_in">good</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="图像转换及二值化"><a href="#图像转换及二值化" class="headerlink" title="图像转换及二值化"></a>图像转换及二值化</h3><p>将输入图像转换为二值化形式。</p><p>cvtColor：将图像转换为灰度图。</p><p>threshold：对灰度图像应用阈值，生成二值图像，背景为黑色，前景为白色。</p><p>返回二值化后的图像。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换图像为01矩阵并进行二值化处理</span></span><br><span class="line"><span class="function">Mat <span class="title">To01Matrix</span><span class="params">(<span class="type">const</span> Mat&amp; image)</span> </span>&#123;</span><br><span class="line">    Mat grayImage;</span><br><span class="line">    <span class="built_in">cvtColor</span>(image, grayImage, COLOR_BGR2GRAY); <span class="comment">//转灰度图像</span></span><br><span class="line">    Mat binaryImage;</span><br><span class="line">    <span class="built_in">threshold</span>(grayImage, binaryImage, <span class="number">128</span>, <span class="number">255</span>, THRESH_BINARY_INV); <span class="comment">// 二值化</span></span><br><span class="line">    <span class="keyword">return</span> binaryImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加载训练数据"><a href="#加载训练数据" class="headerlink" title="加载训练数据"></a>加载训练数据</h3><p>遍历指定路径trainPath下所有的文件，避免了文件名乱糟糟不好写的情况，加载图像提取特征和标签.</p><p>fs::directory_iterator(trainPath)：遍历指定路径中的文件和目录。</p><p>entry.path().string()：获取当前文件&#x2F;目录的完整路径。</p><p>检查文件是否存在且为常规文件，并加载图像。</p><p>如果读取成功，则获取图像的特征，提取标签，并将 <code>xlsj</code> 结构体添加到 <code>trainDataSet</code> 向量中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载训练数据</span></span><br><span class="line"><span class="function">vector&lt;xlsj&gt; <span class="title">loadTrainData</span><span class="params">(<span class="type">const</span> string&amp; trainPath)</span> </span>&#123;</span><br><span class="line">    vector&lt;xlsj&gt; trainDataSet;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; entry : fs::<span class="built_in">directory_iterator</span>(trainPath)) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; filePath = entry.<span class="built_in">path</span>().<span class="built_in">string</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印遍历到的文件名</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;尝试加载图像: &quot;</span> &lt;&lt; filePath &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fs::<span class="built_in">is_regular_file</span>(entry) &amp;&amp; <span class="built_in">fileExists</span>(filePath)) &#123;</span><br><span class="line">            Mat image = <span class="built_in">imread</span>(filePath);</span><br><span class="line">            <span class="keyword">if</span> (image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;无法加载图像 &quot;</span> &lt;&lt; filePath &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 忽略无法加载的图像</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Mat features = <span class="built_in">To01Matrix</span>(image).<span class="built_in">reshape</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 展平成一维特征向量</span></span><br><span class="line">           <span class="comment">// features.convertTo(features, CV_32F); // 转换特征矩阵为浮点型</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从文件名中提取标签</span></span><br><span class="line">            <span class="type">int</span> label = <span class="built_in">stoi</span>(filePath.<span class="built_in">substr</span>(trainPath.<span class="built_in">size</span>(), filePath.<span class="built_in">find_last_of</span>(<span class="string">&#x27;-&#x27;</span>) - trainPath.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">            xlsj data;</span><br><span class="line">            data.features = features;</span><br><span class="line">            data.label = label;</span><br><span class="line">            trainDataSet.<span class="built_in">push_back</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;文件 &quot;</span> &lt;&lt; filePath &lt;&lt; <span class="string">&quot; 不是常规文件或不存在!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;加载的训练数据数量: &quot;</span> &lt;&lt; trainDataSet.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> trainDataSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="训练-KNN-模型"><a href="#训练-KNN-模型" class="headerlink" title="训练 KNN 模型"></a>训练 KNN 模型</h3><p>从训练数据集中提取特征和标签，并使用这些数据训练 KNN 模型。</p><p>push_back：将每个特征和标签添加到相应的矩阵中。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">featureMatrix.<span class="built_in">push_back</span>(data.features);</span><br><span class="line">        labelMatrix.<span class="built_in">push_back</span>(data.label);</span><br></pre></td></tr></table></figure><p>将当前数据点的特征和标签添加到特征和标签矩阵中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ptr&lt;KNearest&gt; knn = KNearest::<span class="built_in">create</span>();</span><br></pre></td></tr></table></figure><p>创建一个智能指针 <code>knn</code>，指向新的KNN模型实例。使用 <code>Ptr</code> 是为了自动管理内存，避免手动释放。</p><p>检查特征和标签矩阵是否为空，若为空则输出错误信息并返回，并将特征矩阵转换为浮点型、标签矩阵转换为整型。创建 KNN 模型并设置 K 值，调用 <code>train</code> 方法训练模型。</p><p>最后返回包含 KNN 模型和特征列数的结构体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123; knn, featureMatrix.cols &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 训练KNN模型</span></span><br><span class="line"><span class="function">KNNModel <span class="title">trainKNN</span><span class="params">(<span class="type">const</span> vector&lt;xlsj&gt;&amp; trainDataSet, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    Mat featureMatrix, labelMatrix; <span class="comment">// 特征与标签矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; data : trainDataSet) &#123;</span><br><span class="line">        featureMatrix.<span class="built_in">push_back</span>(data.features);</span><br><span class="line">        labelMatrix.<span class="built_in">push_back</span>(data.label);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查特征和标签矩阵</span></span><br><span class="line">    <span class="keyword">if</span> (featureMatrix.<span class="built_in">empty</span>() || labelMatrix.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;特征矩阵或标签矩阵为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="literal">nullptr</span>, <span class="number">-1</span> &#125;; <span class="comment">// 返回空指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    featureMatrix.<span class="built_in">convertTo</span>(featureMatrix, CV_32F); <span class="comment">// 转换特征矩阵为浮点型</span></span><br><span class="line">    labelMatrix.<span class="built_in">convertTo</span>(labelMatrix, CV_32S); <span class="comment">// 转换标签矩阵为整数型</span></span><br><span class="line"></span><br><span class="line">    Ptr&lt;KNearest&gt; knn = KNearest::<span class="built_in">create</span>();</span><br><span class="line">    knn-&gt;<span class="built_in">setDefaultK</span>(k);</span><br><span class="line">    knn-&gt;<span class="built_in">train</span>(featureMatrix, ROW_SAMPLE, labelMatrix);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;KNN模型训练完成&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> &#123; knn, featureMatrix.cols &#125;;  <span class="comment">// 返回 KNN 模型以及特征矩阵的列数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-KNN-进行数字识别"><a href="#使用-KNN-进行数字识别" class="headerlink" title="使用 KNN 进行数字识别"></a>使用 KNN 进行数字识别</h3><p>接受测试图像并返回预测的标签。</p><p>将测试图像转换为 01 矩阵，并展平为特征向量,并且确保特征矩阵为浮点型。</p><p>然后调用 <code>findNearest</code> 方法找到最近的 K 个邻居，并返回结果、标签和距离。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knn-&gt;<span class="built_in">findNearest</span>(features, <span class="number">1</span>, result, resultLabels, resultDistances);</span><br></pre></td></tr></table></figure><p>调用 KNN 模型的成员函数 <code>findNearest</code> 来寻找最近的 K 个邻居。</p><p>参数说明：</p><p>features: 输入的特征向量，用于识别。</p><p>1: K值，指定要查找的邻居的数量，这里设置为1，即找到最近的一个邻居。</p><p>result: 用于存储识别结果的矩阵。</p><p>resultLabels: 用于存储最近邻的标签信息。</p><p>resultDistances: 用于存储最近邻的距离信息。</p><p>最后从结果标签中转整形提取预测的数字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用KNN进行识别</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recognizeDigit</span><span class="params">(<span class="type">const</span> Ptr&lt;KNearest&gt;&amp; knn, <span class="type">const</span> Mat&amp; testImage)</span> </span>&#123;</span><br><span class="line">    Mat features = <span class="built_in">To01Matrix</span>(testImage).<span class="built_in">reshape</span>(<span class="number">1</span>, <span class="number">1</span>);<span class="comment">//转01矩阵的特征</span></span><br><span class="line">    features.<span class="built_in">convertTo</span>(features, CV_32F); <span class="comment">// 转换特征矩阵为浮点型</span></span><br><span class="line">    Mat result;<span class="comment">//结果</span></span><br><span class="line">    Mat resultLabels;<span class="comment">//结果标签</span></span><br><span class="line">    Mat resultDistances;<span class="comment">//结果距离</span></span><br><span class="line">    knn-&gt;<span class="built_in">findNearest</span>(features, <span class="number">1</span>, result, resultLabels, resultDistances);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)resultLabels.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// k值</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">5</span>;</span><br><span class="line">    string n = <span class="string">&quot;9&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路径</span></span><br><span class="line">    string testPath = <span class="string">R&quot;(C:\cyuyan\KNNmain\data\test\)&quot;</span> + n + <span class="string">&quot;.jpg&quot;</span>;</span><br><span class="line">    string trainPath = <span class="string">R&quot;(C:\cyuyan\KNNmain\data\xl\)&quot;</span>;</span><br><span class="line">    <span class="comment">// Mat src = imread(testPath);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载训练数据</span></span><br><span class="line">    vector&lt;xlsj&gt; trainDataSet = <span class="built_in">loadTrainData</span>(trainPath);</span><br><span class="line">    <span class="keyword">if</span> (trainDataSet.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有训练数据!&quot;</span> &lt;&lt; endl; <span class="comment">// 查询训练数据是否存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 训练 KNN 模型</span></span><br><span class="line">    KNNModel model = <span class="built_in">trainKNN</span>(trainDataSet, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!model.knn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//判断trainKNN是否正常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载测试图像</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">fileExists</span>(testPath)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;测试文件 &quot;</span> &lt;&lt; testPath &lt;&lt; <span class="string">&quot; 不存在!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mat testImage = <span class="built_in">imread</span>(testPath);</span><br><span class="line">    <span class="keyword">if</span> (testImage.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无法加载图像&quot;</span> &lt;&lt; testPath &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行识别</span></span><br><span class="line">    Mat features = <span class="built_in">To01Matrix</span>(testImage).<span class="built_in">reshape</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 转01矩阵的特征</span></span><br><span class="line">    features.<span class="built_in">convertTo</span>(features, CV_32F); <span class="comment">// 转换特征矩阵为浮点型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断特征数量与训练特征是否一样</span></span><br><span class="line">    <span class="keyword">if</span> (features.cols != model.numFeatures) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;测试样本的特征数量与训练样本不匹配&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//namedWindow(&quot;test opencv setup&quot;, CV_WINDOW_AUTOSIZE);</span></span><br><span class="line">    <span class="comment">//imshow(&quot;test opencv setup&quot;, src);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">recognizeDigit</span>(model.knn, testImage);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;预测结果: &quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贴一下完整代码"><a href="#贴一下完整代码" class="headerlink" title="贴一下完整代码"></a>贴一下完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui_c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/ml.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv::ml;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 训练数据结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">xlsj</span> &#123;</span><br><span class="line">    Mat features;  <span class="comment">// 特征向量</span></span><br><span class="line">    <span class="type">int</span> label;     <span class="comment">// 标签</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">KNNModel</span> &#123;</span><br><span class="line">    Ptr&lt;KNearest&gt; knn;</span><br><span class="line">    <span class="type">int</span> numFeatures;  <span class="comment">// 特征矩阵的列数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查文件是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fileExists</span><span class="params">(<span class="type">const</span> string&amp; filePath)</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">file</span><span class="params">(filePath)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> file.<span class="built_in">good</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换图像为01矩阵并进行二值化处理</span></span><br><span class="line"><span class="function">Mat <span class="title">To01Matrix</span><span class="params">(<span class="type">const</span> Mat&amp; image)</span> </span>&#123;</span><br><span class="line">    Mat grayImage;</span><br><span class="line">    <span class="built_in">cvtColor</span>(image, grayImage, COLOR_BGR2GRAY); <span class="comment">//转灰度图像</span></span><br><span class="line">    Mat binaryImage;</span><br><span class="line">    <span class="built_in">threshold</span>(grayImage, binaryImage, <span class="number">128</span>, <span class="number">255</span>, THRESH_BINARY_INV); <span class="comment">// 二值化</span></span><br><span class="line">    <span class="keyword">return</span> binaryImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载训练数据</span></span><br><span class="line"><span class="function">vector&lt;xlsj&gt; <span class="title">loadTrainData</span><span class="params">(<span class="type">const</span> string&amp; trainPath)</span> </span>&#123;</span><br><span class="line">    vector&lt;xlsj&gt; trainDataSet;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; entry : fs::<span class="built_in">directory_iterator</span>(trainPath)) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; filePath = entry.<span class="built_in">path</span>().<span class="built_in">string</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印遍历到的文件名</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;尝试加载图像: &quot;</span> &lt;&lt; filePath &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fs::<span class="built_in">is_regular_file</span>(entry) &amp;&amp; <span class="built_in">fileExists</span>(filePath)) &#123;</span><br><span class="line">            Mat image = <span class="built_in">imread</span>(filePath);</span><br><span class="line">            <span class="keyword">if</span> (image.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;无法加载图像 &quot;</span> &lt;&lt; filePath &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 忽略无法加载的图像</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Mat features = <span class="built_in">To01Matrix</span>(image).<span class="built_in">reshape</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 展平成一维特征向量</span></span><br><span class="line">           <span class="comment">// features.convertTo(features, CV_32F); // 转换特征矩阵为浮点型</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从文件名中提取标签</span></span><br><span class="line">            <span class="type">int</span> label = <span class="built_in">stoi</span>(filePath.<span class="built_in">substr</span>(trainPath.<span class="built_in">size</span>(), filePath.<span class="built_in">find_last_of</span>(<span class="string">&#x27;-&#x27;</span>) - trainPath.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">            xlsj data;</span><br><span class="line">            data.features = features;</span><br><span class="line">            data.label = label;</span><br><span class="line">            trainDataSet.<span class="built_in">push_back</span>(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;文件 &quot;</span> &lt;&lt; filePath &lt;&lt; <span class="string">&quot; 不是常规文件或不存在!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;加载的训练数据数量: &quot;</span> &lt;&lt; trainDataSet.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> trainDataSet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 训练KNN模型</span></span><br><span class="line"><span class="function">KNNModel <span class="title">trainKNN</span><span class="params">(<span class="type">const</span> vector&lt;xlsj&gt;&amp; trainDataSet, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    Mat featureMatrix, labelMatrix; <span class="comment">// 特征与标签矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; data : trainDataSet) &#123;</span><br><span class="line">        featureMatrix.<span class="built_in">push_back</span>(data.features);</span><br><span class="line">        labelMatrix.<span class="built_in">push_back</span>(data.label);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查特征和标签矩阵</span></span><br><span class="line">    <span class="keyword">if</span> (featureMatrix.<span class="built_in">empty</span>() || labelMatrix.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;特征矩阵或标签矩阵为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="literal">nullptr</span>, <span class="number">-1</span> &#125;; <span class="comment">// 返回空指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    featureMatrix.<span class="built_in">convertTo</span>(featureMatrix, CV_32F); <span class="comment">// 转换特征矩阵为浮点型</span></span><br><span class="line">    labelMatrix.<span class="built_in">convertTo</span>(labelMatrix, CV_32S); <span class="comment">// 转换标签矩阵为整数型</span></span><br><span class="line"></span><br><span class="line">    Ptr&lt;KNearest&gt; knn = KNearest::<span class="built_in">create</span>();</span><br><span class="line">    knn-&gt;<span class="built_in">setDefaultK</span>(k);</span><br><span class="line">    knn-&gt;<span class="built_in">train</span>(featureMatrix, ROW_SAMPLE, labelMatrix);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;KNN模型训练完成&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> &#123; knn, featureMatrix.cols &#125;;  <span class="comment">// 返回 KNN 模型以及特征矩阵的列数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用KNN进行识别</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recognizeDigit</span><span class="params">(<span class="type">const</span> Ptr&lt;KNearest&gt;&amp; knn, <span class="type">const</span> Mat&amp; testImage)</span> </span>&#123;</span><br><span class="line">    Mat features = <span class="built_in">To01Matrix</span>(testImage).<span class="built_in">reshape</span>(<span class="number">1</span>, <span class="number">1</span>);<span class="comment">//转01矩阵的特征</span></span><br><span class="line">    features.<span class="built_in">convertTo</span>(features, CV_32F); <span class="comment">// 转换特征矩阵为浮点型</span></span><br><span class="line">    Mat result;<span class="comment">//结果</span></span><br><span class="line">    Mat resultLabels;<span class="comment">//结果标签</span></span><br><span class="line">    Mat resultDistances;<span class="comment">//结果距离</span></span><br><span class="line">    knn-&gt;<span class="built_in">findNearest</span>(features, <span class="number">1</span>, result, resultLabels, resultDistances);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)resultLabels.<span class="built_in">at</span>&lt;<span class="type">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// k值</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">5</span>;</span><br><span class="line">    string n = <span class="string">&quot;9&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路径</span></span><br><span class="line">    string testPath = <span class="string">R&quot;(C:\cyuyan\KNNmain\data\test\)&quot;</span> + n + <span class="string">&quot;.jpg&quot;</span>;</span><br><span class="line">    string trainPath = <span class="string">R&quot;(C:\cyuyan\KNNmain\data\xl\)&quot;</span>;</span><br><span class="line">    <span class="comment">// Mat src = imread(testPath);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载训练数据</span></span><br><span class="line">    vector&lt;xlsj&gt; trainDataSet = <span class="built_in">loadTrainData</span>(trainPath);</span><br><span class="line">    <span class="keyword">if</span> (trainDataSet.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有训练数据!&quot;</span> &lt;&lt; endl; <span class="comment">// 查询训练数据是否存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 训练 KNN 模型</span></span><br><span class="line">    KNNModel model = <span class="built_in">trainKNN</span>(trainDataSet, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!model.knn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//判断trainKNN是否正常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载测试图像</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">fileExists</span>(testPath)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;测试文件 &quot;</span> &lt;&lt; testPath &lt;&lt; <span class="string">&quot; 不存在!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mat testImage = <span class="built_in">imread</span>(testPath);</span><br><span class="line">    <span class="keyword">if</span> (testImage.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无法加载图像&quot;</span> &lt;&lt; testPath &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行识别</span></span><br><span class="line">    Mat features = <span class="built_in">To01Matrix</span>(testImage).<span class="built_in">reshape</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 转01矩阵的特征</span></span><br><span class="line">    features.<span class="built_in">convertTo</span>(features, CV_32F); <span class="comment">// 转换特征矩阵为浮点型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断特征数量与训练特征是否一样</span></span><br><span class="line">    <span class="keyword">if</span> (features.cols != model.numFeatures) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;测试样本的特征数量与训练样本不匹配&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//namedWindow(&quot;test opencv setup&quot;, CV_WINDOW_AUTOSIZE);</span></span><br><span class="line">    <span class="comment">//imshow(&quot;test opencv setup&quot;, src);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">recognizeDigit</span>(model.knn, testImage);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;预测结果: &quot;</span> &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EaxyX的使用笔记</title>
      <link href="/2024/05/19/EasyX%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/05/19/EasyX%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-创建图形化窗口"><a href="#1-创建图形化窗口" class="headerlink" title="1.创建图形化窗口"></a>1.创建图形化窗口</h2><p>图形化处理不支持C语言输入输出函数</p><p>可以通过打印函数在控制台调试错误</p><p>1.1头文件:</p><p>graphics.h(包含已经被淘汰的函数)</p><p>easyx.h(只包含最新的函数)</p><p>1.2创建窗口:</p><p>initgraph(int x,int y,int style);打开,x,y表示窗口大小，style表示打开方式(不写style则只打开图形化处理窗口)</p><p>closegraph();关闭窗口,前一句要加while(1)防止闪屏</p><p>1.3窗口坐标:</p><p>两点确认一条线，横x，纵y</p><p>1.4设置窗口属性:</p><p>1.4.1颜色设置:setbkcolor,分为两种，分别是颜色宏和RGB配置，颜色宏是英语大写的单词，右键可以查看库里的颜色函数,RGB配置就是三原色R G B的参数（类似调色板)</p><p>颜色宏:setbkcolor(RED);</p><p>RGB配置:setbkcolor(RGB(0,0,0))，则是黑色</p><p>1.5窗口刷新:</p><p>不设置窗口刷新是不会显示的</p><p>cleardevice()</p><h2 id="2-绘图函数-int不用写"><a href="#2-绘图函数-int不用写" class="headerlink" title="2.绘图函数(int不用写)"></a>2.绘图函数(int不用写)</h2><p>2.1画线line(int x,int y,int xx,int yy);两个坐标，确定一条线</p><p>2.2画圆circle(int x,int y,int r);坐标，半径</p><p>2.3矩形rectangle(int x,int y,int xx,int yy);两个坐标，确定一个矩形</p><p>2.4填充圆和填充矩形颜色:setfillcolor();改变线的颜色:setlinecolor();</p><p>2.4.1圆带线填充:fillcircle(int x,int y,int r);</p><p>不带线填充:solidcircle(int x,int y,int r);</p><p>2.4.2矩形带线填充:fillrectangle(int x,int y,int xx,int yy);</p><p>矩形不带线填充:solidrectangle(int x,int y,int xx,int yy);</p><p>2.5窗口绘图可以使用for等函数进行绘图，比如画棋盘</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">qipan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">400</span>, <span class="number">400</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">400</span>; i += <span class="number">20</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">line</span>(<span class="number">0</span>, i, <span class="number">400</span>, i);</span><br><span class="line"><span class="built_in">line</span>(i, <span class="number">0</span>, i, <span class="number">400</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"><span class="built_in">closegraph</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.6显示贴图双缓冲，解决一闪一闪的刷新率问题:</p><p>在创建窗口initgraph函数下加BeginBatchDraw();在结尾closegraph函数上加EndBatchDraw();在循环里最后加上显示每一帧FlushBatchDraw();</p><h2 id="3-贴图"><a href="#3-贴图" class="headerlink" title="3.贴图"></a>3.贴图</h2><p>3.1原式贴图</p><p>3.1.1IMAGE变量表示图片</p><p>加载图像:loadimage(IMAGE* img,URL);</p><p>缩放加载:loadimage(IMAGE* img,URL,int width,int height);width表示宽，height表示高</p><p>3.1.2显示图像:putimage(int x,int y,IMAGE* img);</p><p>例如加载一张名为tcs.jpg的图片</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IMAGE img;</span><br><span class="line"><span class="built_in">loadimage</span>(&amp;img,<span class="string">&quot;./Res/tcs.jpg&quot;</span>);</span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">0</span>,<span class="number">0</span>,&amp;img);</span><br></pre></td></tr></table></figure><p>3.2 透明贴图</p><p>3.2.1通过图像的颜色二进制运算达到去背景图的效果</p><p>3.2.2素材：掩码图，背景图</p><p>3.2.3按照特定步骤贴图:</p><p>SRCAND 掩码图</p><p>SRCPAINT 背景图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMAGE test[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">loadimage</span>(test+<span class="number">0</span>,<span class="string">&quot;./Res/test.jpg&quot;</span>);</span><br><span class="line"><span class="built_in">loadimage</span>(test+<span class="number">1</span>,<span class="string">&quot;./Res/testbk.jpg&quot;</span>);</span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">100</span>,<span class="number">100</span>,test+<span class="number">0</span>,SRCAND);</span><br><span class="line"><span class="built_in">putimage</span>(<span class="number">100</span>,<span class="number">100</span>,test+<span class="number">1</span>,SRCPAINT);</span><br></pre></td></tr></table></figure><h2 id="4-按键交互"><a href="#4-按键交互" class="headerlink" title="4.按键交互"></a>4.按键交互</h2><p>4.1阻塞按键交互:C++写的函数几乎都是阻塞，例如写一个小球移动和反弹</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Ball</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">int</span> dx;</span><br><span class="line"><span class="type">int</span> dy;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ball</span> ball = &#123; <span class="number">400</span>,<span class="number">400</span>,<span class="number">15</span>,<span class="number">6</span>,<span class="number">-5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawBall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">setfillcolor</span>(RED);</span><br><span class="line"><span class="built_in">solidcircle</span>(ball.x, ball.y, ball.r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MoveBall</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ball.x - ball.r &lt;= <span class="number">0</span> || ball.x + ball.r &gt;= <span class="number">800</span>)</span><br><span class="line">&#123;</span><br><span class="line">ball.dx = -ball.dx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ball.y - ball.r &lt;= <span class="number">0</span> || ball.y + ball.r &gt;= <span class="number">800</span>)</span><br><span class="line">&#123;</span><br><span class="line">ball.dy = -ball.dy;</span><br><span class="line">&#125;</span><br><span class="line">ball.x += ball.dx;</span><br><span class="line">ball.y += ball.dy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">initgraph</span>(<span class="number">800</span>, <span class="number">800</span>);</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cleardevice</span>();</span><br><span class="line"><span class="built_in">DrawBall</span>();</span><br><span class="line"><span class="built_in">MoveBall</span>();</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">closegraph</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用结构体封装小球的数据，声明小球的绘图和移动方式,Sleep()是标准库里的移动速度函数</p><p>4.2用户输入按键对图像进行操控</p><p>4.2.1头文件</p><p>#include &lt;conio.h&gt;（getch()不需要回车确认输入)</p><p>4.2.2创建操控框架</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">keydown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> userkey = _getch();</span><br><span class="line"><span class="keyword">switch</span> (userkey)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span><span class="number">&#x27;</span>W<span class="number">&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">72</span>:</span><br><span class="line">myball.y -= <span class="number">5</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span><span class="number">&#x27;</span>s<span class="number">&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span><span class="number">&#x27;</span>S<span class="number">&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">80</span>:</span><br><span class="line">myball.y += <span class="number">5</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span><span class="number">&#x27;</span>a<span class="number">&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span><span class="number">&#x27;</span>A<span class="number">&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">75</span>:</span><br><span class="line">myball.x -= <span class="number">5</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span><span class="number">&#x27;</span>d<span class="number">&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span><span class="number">&#x27;</span>D<span class="number">&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">77</span>:</span><br><span class="line">myball.x += <span class="number">5</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用这个框架后如果发现其他图像在你不操控时也不动，那就是因为阻塞的原因，需要加上判断存在按键操作再处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(_kbhit())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">keydown</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sleep也是阻塞函数，想流畅运行要用定时器函数</p><p>4.3定时器函数</p><p>4.3.1定时器要用到时间函数，要加上#include&lt;time.h&gt;头文件</p><p>4.3.2定时器输入时间间隔和定时器id,用静态变量记录每一次的结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Time</span><span class="params">(<span class="type">int</span> sjjg,<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> startTime[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> endTime=<span class="built_in">clock</span>();<span class="comment">//clock统计程序运行到当前代码时间</span></span><br><span class="line"><span class="keyword">if</span>(endTime-startTime[id]&gt;sjjg)<span class="comment">//时间间隔大于定时器时间间隔触发定时器</span></span><br><span class="line">&#123;</span><br><span class="line">startTime[id]=endTime;<span class="comment">//开始时间改为上一次结束时间</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用到图像移动函数处,例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">Time</span>(<span class="number">20</span>,<span class="number">0</span>))</span><br><span class="line"><span class="built_in">MoveBall</span>();</span><br></pre></td></tr></table></figure><p>4.4异步交互:</p><p>4.4.1非阻塞函数，比上面所写的更流畅，但要控制好定时器速度比如Time(20,1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">keydown2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">GetAsyncKeyState</span>(VK_UP))</span><br><span class="line">&#123;</span><br><span class="line"> myball.y-=<span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">GetAsyncKeyState</span>(VK_DOWN))</span><br><span class="line">&#123;</span><br><span class="line"> myball.y+=<span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">GetAsyncKeyState</span>(VK_LEFT))</span><br><span class="line">&#123;</span><br><span class="line"> myball.x-=<span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">GetAsyncKeyState</span>(VK_RIGHT))</span><br><span class="line">&#123;</span><br><span class="line"> myball.x+=<span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-鼠标交互"><a href="#5-鼠标交互" class="headerlink" title="5.鼠标交互"></a>5.鼠标交互</h2><p>5.1写一个ExMessage类型变量去存储鼠标消息</p><p>5.2获取鼠标消息peekmessage(&amp;变量)</p><p>5.3讨论鼠标消息</p><p>msg.message(区分鼠标消息类型)</p><p>msg.x msg.y（鼠标当前坐标）</p><p>5.4框架示例(鼠标左键画圆，右键画方)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ExMessage msg;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">peekmessage</span>(&amp;msg))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>(msg.message)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line"><span class="built_in">circle</span>(msg.x,msg.y,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WM_RBUTTONDOWN:</span><br><span class="line"><span class="built_in">rectangle</span>(msg.x<span class="number">-10</span>,msg.y<span class="number">-10</span>,msg.x+<span class="number">10</span>,msg.y+<span class="number">10</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战项目后面会发一个贪吃蛇和AI寻路贪吃蛇"><a href="#实战项目后面会发一个贪吃蛇和AI寻路贪吃蛇" class="headerlink" title="实战项目后面会发一个贪吃蛇和AI寻路贪吃蛇"></a>实战项目后面会发一个贪吃蛇和AI寻路贪吃蛇</h2>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EaxyX库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
